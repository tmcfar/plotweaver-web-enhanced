"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useWebSocket.ts":
/*!***********************************!*\
  !*** ./src/hooks/useWebSocket.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEnhancedWebSocket: () => (/* binding */ useEnhancedWebSocket),\n/* harmony export */   useWebSocket: () => (/* binding */ useWebSocket)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst useEnhancedWebSocket = (projectId)=>{\n    const [connectionStatus, setConnectionStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('disconnected');\n    const ws = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const subscriptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    const messageQueue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const reconnectAttempts = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const maxReconnectAttempts = 5;\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useEnhancedWebSocket.useCallback[connect]\": ()=>{\n            try {\n                ws.current = new WebSocket('ws://localhost:8000/ws');\n                ws.current.onopen = ({\n                    \"useEnhancedWebSocket.useCallback[connect]\": ()=>{\n                        console.log('WebSocket connected');\n                        setConnectionStatus('connected');\n                        reconnectAttempts.current = 0;\n                        // Send queued messages\n                        messageQueue.current.forEach({\n                            \"useEnhancedWebSocket.useCallback[connect]\": (param)=>{\n                                let { channel, data } = param;\n                                send(channel, data);\n                            }\n                        }[\"useEnhancedWebSocket.useCallback[connect]\"]);\n                        messageQueue.current = [];\n                    }\n                })[\"useEnhancedWebSocket.useCallback[connect]\"];\n                ws.current.onmessage = ({\n                    \"useEnhancedWebSocket.useCallback[connect]\": (event)=>{\n                        try {\n                            const message = JSON.parse(event.data);\n                            // Handle different message formats\n                            if (message.channel && message.data) {\n                                // Channel-based message\n                                const callback = subscriptions.current.get(message.channel);\n                                if (callback) {\n                                    callback(message.data);\n                                }\n                            } else if (message.type) {\n                                // Type-based message (existing format)\n                                const callback = subscriptions.current.get(message.type);\n                                if (callback) {\n                                    callback(message);\n                                }\n                            } else {\n                                // Plain message (fallback for existing simple messages)\n                                const callback = subscriptions.current.get('message');\n                                if (callback) {\n                                    callback(event.data);\n                                }\n                            }\n                        } catch (error) {\n                            console.error('Error parsing WebSocket message:', error);\n                            // Handle non-JSON messages (existing behavior)\n                            const callback = subscriptions.current.get('message');\n                            if (callback) {\n                                callback(event.data);\n                            }\n                        }\n                    }\n                })[\"useEnhancedWebSocket.useCallback[connect]\"];\n                ws.current.onclose = ({\n                    \"useEnhancedWebSocket.useCallback[connect]\": ()=>{\n                        console.log('WebSocket disconnected');\n                        setConnectionStatus('disconnected');\n                        // Attempt reconnection with exponential backoff\n                        if (reconnectAttempts.current < maxReconnectAttempts) {\n                            const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 10000);\n                            reconnectAttempts.current++;\n                            setTimeout({\n                                \"useEnhancedWebSocket.useCallback[connect]\": ()=>{\n                                    console.log(\"Reconnecting... (attempt \".concat(reconnectAttempts.current, \")\"));\n                                    setConnectionStatus('reconnecting');\n                                    connect();\n                                }\n                            }[\"useEnhancedWebSocket.useCallback[connect]\"], delay);\n                        } else {\n                            console.error('Max reconnection attempts reached');\n                        }\n                    }\n                })[\"useEnhancedWebSocket.useCallback[connect]\"];\n                ws.current.onerror = ({\n                    \"useEnhancedWebSocket.useCallback[connect]\": (error)=>{\n                        console.error('WebSocket error:', error);\n                    }\n                })[\"useEnhancedWebSocket.useCallback[connect]\"];\n            } catch (error) {\n                console.error('Failed to create WebSocket connection:', error);\n                setConnectionStatus('disconnected');\n            }\n        }\n    }[\"useEnhancedWebSocket.useCallback[connect]\"], []);\n    const subscribe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useEnhancedWebSocket.useCallback[subscribe]\": (channel, callback)=>{\n            subscriptions.current.set(channel, callback);\n        }\n    }[\"useEnhancedWebSocket.useCallback[subscribe]\"], []);\n    const unsubscribe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useEnhancedWebSocket.useCallback[unsubscribe]\": (channel)=>{\n            subscriptions.current.delete(channel);\n        }\n    }[\"useEnhancedWebSocket.useCallback[unsubscribe]\"], []);\n    const send = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useEnhancedWebSocket.useCallback[send]\": (channel, data)=>{\n            var _ws_current;\n            if (((_ws_current = ws.current) === null || _ws_current === void 0 ? void 0 : _ws_current.readyState) === WebSocket.OPEN) {\n                try {\n                    // Try to send as structured message first\n                    ws.current.send(JSON.stringify({\n                        channel,\n                        data\n                    }));\n                } catch (error) {\n                    // Fallback to simple string message (existing behavior)\n                    ws.current.send(typeof data === 'string' ? data : JSON.stringify(data));\n                }\n            } else {\n                // Queue message for later\n                messageQueue.current.push({\n                    channel,\n                    data\n                });\n            }\n        }\n    }[\"useEnhancedWebSocket.useCallback[send]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useEnhancedWebSocket.useEffect\": ()=>{\n            connect();\n            return ({\n                \"useEnhancedWebSocket.useEffect\": ()=>{\n                    if (ws.current) {\n                        ws.current.close();\n                    }\n                }\n            })[\"useEnhancedWebSocket.useEffect\"];\n        }\n    }[\"useEnhancedWebSocket.useEffect\"], [\n        connect\n    ]);\n    return {\n        connectionStatus,\n        subscribe,\n        unsubscribe,\n        send\n    };\n};\n// Keep the original hook for backward compatibility\nconst useWebSocket = (url)=>{\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [lastMessage, setLastMessage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const ws = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useWebSocket.useEffect\": ()=>{\n            ws.current = new WebSocket(url);\n            ws.current.onopen = ({\n                \"useWebSocket.useEffect\": ()=>{\n                    setIsConnected(true);\n                    console.log('WebSocket connected');\n                }\n            })[\"useWebSocket.useEffect\"];\n            ws.current.onmessage = ({\n                \"useWebSocket.useEffect\": (event)=>{\n                    setLastMessage(event.data);\n                }\n            })[\"useWebSocket.useEffect\"];\n            ws.current.onclose = ({\n                \"useWebSocket.useEffect\": ()=>{\n                    setIsConnected(false);\n                    console.log('WebSocket disconnected');\n                }\n            })[\"useWebSocket.useEffect\"];\n            ws.current.onerror = ({\n                \"useWebSocket.useEffect\": (error)=>{\n                    console.error('WebSocket error:', error);\n                }\n            })[\"useWebSocket.useEffect\"];\n            return ({\n                \"useWebSocket.useEffect\": ()=>{\n                    var _ws_current;\n                    (_ws_current = ws.current) === null || _ws_current === void 0 ? void 0 : _ws_current.close();\n                }\n            })[\"useWebSocket.useEffect\"];\n        }\n    }[\"useWebSocket.useEffect\"], [\n        url\n    ]);\n    const sendMessage = (message)=>{\n        var _ws_current;\n        if (((_ws_current = ws.current) === null || _ws_current === void 0 ? void 0 : _ws_current.readyState) === WebSocket.OPEN) {\n            ws.current.send(message);\n        }\n    };\n    return {\n        isConnected,\n        lastMessage,\n        sendMessage\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VXZWJTb2NrZXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRTtBQVMxRCxNQUFNSSx1QkFBdUIsQ0FBQ0M7SUFDbkMsTUFBTSxDQUFDQyxrQkFBa0JDLG9CQUFvQixHQUFHTCwrQ0FBUUEsQ0FBZ0Q7SUFDeEcsTUFBTU0sS0FBS1AsNkNBQU1BLENBQW1CO0lBQ3BDLE1BQU1RLGdCQUFnQlIsNkNBQU1BLENBQW1DLElBQUlTO0lBQ25FLE1BQU1DLGVBQWVWLDZDQUFNQSxDQUFzQyxFQUFFO0lBQ25FLE1BQU1XLG9CQUFvQlgsNkNBQU1BLENBQUM7SUFDakMsTUFBTVksdUJBQXVCO0lBRTdCLE1BQU1DLFVBQVVYLGtEQUFXQTtxREFBQztZQUMxQixJQUFJO2dCQUNGSyxHQUFHTyxPQUFPLEdBQUcsSUFBSUMsVUFBVTtnQkFFM0JSLEdBQUdPLE9BQU8sQ0FBQ0UsTUFBTTtpRUFBRzt3QkFDbEJDLFFBQVFDLEdBQUcsQ0FBQzt3QkFDWlosb0JBQW9CO3dCQUNwQkssa0JBQWtCRyxPQUFPLEdBQUc7d0JBRTVCLHVCQUF1Qjt3QkFDdkJKLGFBQWFJLE9BQU8sQ0FBQ0ssT0FBTzt5RUFBQztvQ0FBQyxFQUFDQyxPQUFPLEVBQUVDLElBQUksRUFBQztnQ0FDM0NDLEtBQUtGLFNBQVNDOzRCQUNoQjs7d0JBQ0FYLGFBQWFJLE9BQU8sR0FBRyxFQUFFO29CQUMzQjs7Z0JBRUFQLEdBQUdPLE9BQU8sQ0FBQ1MsU0FBUztpRUFBRyxDQUFDQzt3QkFDdEIsSUFBSTs0QkFDRixNQUFNQyxVQUFVQyxLQUFLQyxLQUFLLENBQUNILE1BQU1ILElBQUk7NEJBRXJDLG1DQUFtQzs0QkFDbkMsSUFBSUksUUFBUUwsT0FBTyxJQUFJSyxRQUFRSixJQUFJLEVBQUU7Z0NBQ25DLHdCQUF3QjtnQ0FDeEIsTUFBTU8sV0FBV3BCLGNBQWNNLE9BQU8sQ0FBQ2UsR0FBRyxDQUFDSixRQUFRTCxPQUFPO2dDQUMxRCxJQUFJUSxVQUFV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YUU7SUFBWTtBQUNqRCxFQUFFIiwic291cmNlcyI6WyIvaG9tZS90bWNmYXIvZGV2L3B3LXdlYi9mcm9udGVuZC9zcmMvaG9va3MvdXNlV2ViU29ja2V0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5cbmludGVyZmFjZSBXZWJTb2NrZXRIb29rIHtcbiAgY29ubmVjdGlvblN0YXR1czogJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJyB8ICdyZWNvbm5lY3RpbmcnO1xuICBzdWJzY3JpYmU6IChjaGFubmVsOiBzdHJpbmcsIGNhbGxiYWNrOiAoZGF0YTogYW55KSA9PiB2b2lkKSA9PiB2b2lkO1xuICB1bnN1YnNjcmliZTogKGNoYW5uZWw6IHN0cmluZykgPT4gdm9pZDtcbiAgc2VuZDogKGNoYW5uZWw6IHN0cmluZywgZGF0YTogYW55KSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgdXNlRW5oYW5jZWRXZWJTb2NrZXQgPSAocHJvamVjdElkOiBzdHJpbmcpOiBXZWJTb2NrZXRIb29rID0+IHtcbiAgY29uc3QgW2Nvbm5lY3Rpb25TdGF0dXMsIHNldENvbm5lY3Rpb25TdGF0dXNdID0gdXNlU3RhdGU8J2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJyB8ICdyZWNvbm5lY3RpbmcnPignZGlzY29ubmVjdGVkJyk7XG4gIGNvbnN0IHdzID0gdXNlUmVmPFdlYlNvY2tldCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBzdWJzY3JpcHRpb25zID0gdXNlUmVmPE1hcDxzdHJpbmcsIChkYXRhOiBhbnkpID0+IHZvaWQ+PihuZXcgTWFwKCkpO1xuICBjb25zdCBtZXNzYWdlUXVldWUgPSB1c2VSZWY8QXJyYXk8e2NoYW5uZWw6IHN0cmluZywgZGF0YTogYW55fT4+KFtdKTtcbiAgY29uc3QgcmVjb25uZWN0QXR0ZW1wdHMgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IG1heFJlY29ubmVjdEF0dGVtcHRzID0gNTtcblxuICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB3cy5jdXJyZW50ID0gbmV3IFdlYlNvY2tldCgnd3M6Ly9sb2NhbGhvc3Q6ODAwMC93cycpO1xuICAgICAgXG4gICAgICB3cy5jdXJyZW50Lm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1dlYlNvY2tldCBjb25uZWN0ZWQnKTtcbiAgICAgICAgc2V0Q29ubmVjdGlvblN0YXR1cygnY29ubmVjdGVkJyk7XG4gICAgICAgIHJlY29ubmVjdEF0dGVtcHRzLmN1cnJlbnQgPSAwO1xuICAgICAgICBcbiAgICAgICAgLy8gU2VuZCBxdWV1ZWQgbWVzc2FnZXNcbiAgICAgICAgbWVzc2FnZVF1ZXVlLmN1cnJlbnQuZm9yRWFjaCgoe2NoYW5uZWwsIGRhdGF9KSA9PiB7XG4gICAgICAgICAgc2VuZChjaGFubmVsLCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1lc3NhZ2VRdWV1ZS5jdXJyZW50ID0gW107XG4gICAgICB9O1xuXG4gICAgICB3cy5jdXJyZW50Lm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgbWVzc2FnZSBmb3JtYXRzXG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhbm5lbCAmJiBtZXNzYWdlLmRhdGEpIHtcbiAgICAgICAgICAgIC8vIENoYW5uZWwtYmFzZWQgbWVzc2FnZVxuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBzdWJzY3JpcHRpb25zLmN1cnJlbnQuZ2V0KG1lc3NhZ2UuY2hhbm5lbCk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sobWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgLy8gVHlwZS1iYXNlZCBtZXNzYWdlIChleGlzdGluZyBmb3JtYXQpXG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHN1YnNjcmlwdGlvbnMuY3VycmVudC5nZXQobWVzc2FnZS50eXBlKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUGxhaW4gbWVzc2FnZSAoZmFsbGJhY2sgZm9yIGV4aXN0aW5nIHNpbXBsZSBtZXNzYWdlcylcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gc3Vic2NyaXB0aW9ucy5jdXJyZW50LmdldCgnbWVzc2FnZScpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIFdlYlNvY2tldCBtZXNzYWdlOicsIGVycm9yKTtcbiAgICAgICAgICAvLyBIYW5kbGUgbm9uLUpTT04gbWVzc2FnZXMgKGV4aXN0aW5nIGJlaGF2aW9yKVxuICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gc3Vic2NyaXB0aW9ucy5jdXJyZW50LmdldCgnbWVzc2FnZScpO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3cy5jdXJyZW50Lm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXZWJTb2NrZXQgZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIHNldENvbm5lY3Rpb25TdGF0dXMoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gQXR0ZW1wdCByZWNvbm5lY3Rpb24gd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgIGlmIChyZWNvbm5lY3RBdHRlbXB0cy5jdXJyZW50IDwgbWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcbiAgICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgubWluKDEwMDAgKiBNYXRoLnBvdygyLCByZWNvbm5lY3RBdHRlbXB0cy5jdXJyZW50KSwgMTAwMDApO1xuICAgICAgICAgIHJlY29ubmVjdEF0dGVtcHRzLmN1cnJlbnQrKztcbiAgICAgICAgICBcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWNvbm5lY3RpbmcuLi4gKGF0dGVtcHQgJHtyZWNvbm5lY3RBdHRlbXB0cy5jdXJyZW50fSlgKTtcbiAgICAgICAgICAgIHNldENvbm5lY3Rpb25TdGF0dXMoJ3JlY29ubmVjdGluZycpO1xuICAgICAgICAgICAgY29ubmVjdCgpO1xuICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdNYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIHJlYWNoZWQnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgd3MuY3VycmVudC5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1dlYlNvY2tldCBlcnJvcjonLCBlcnJvcik7XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIFdlYlNvY2tldCBjb25uZWN0aW9uOicsIGVycm9yKTtcbiAgICAgIHNldENvbm5lY3Rpb25TdGF0dXMoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IHN1YnNjcmliZSA9IHVzZUNhbGxiYWNrKChjaGFubmVsOiBzdHJpbmcsIGNhbGxiYWNrOiAoZGF0YTogYW55KSA9PiB2b2lkKSA9PiB7XG4gICAgc3Vic2NyaXB0aW9ucy5jdXJyZW50LnNldChjaGFubmVsLCBjYWxsYmFjayk7XG4gIH0sIFtdKTtcblxuICBjb25zdCB1bnN1YnNjcmliZSA9IHVzZUNhbGxiYWNrKChjaGFubmVsOiBzdHJpbmcpID0+IHtcbiAgICBzdWJzY3JpcHRpb25zLmN1cnJlbnQuZGVsZXRlKGNoYW5uZWwpO1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgc2VuZCA9IHVzZUNhbGxiYWNrKChjaGFubmVsOiBzdHJpbmcsIGRhdGE6IGFueSkgPT4ge1xuICAgIGlmICh3cy5jdXJyZW50Py5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVHJ5IHRvIHNlbmQgYXMgc3RydWN0dXJlZCBtZXNzYWdlIGZpcnN0XG4gICAgICAgIHdzLmN1cnJlbnQuc2VuZChKU09OLnN0cmluZ2lmeSh7IGNoYW5uZWwsIGRhdGEgfSkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gc2ltcGxlIHN0cmluZyBtZXNzYWdlIChleGlzdGluZyBiZWhhdmlvcilcbiAgICAgICAgd3MuY3VycmVudC5zZW5kKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFF1ZXVlIG1lc3NhZ2UgZm9yIGxhdGVyXG4gICAgICBtZXNzYWdlUXVldWUuY3VycmVudC5wdXNoKHsgY2hhbm5lbCwgZGF0YSB9KTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbm5lY3QoKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHdzLmN1cnJlbnQpIHtcbiAgICAgICAgd3MuY3VycmVudC5jbG9zZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtjb25uZWN0XSk7XG5cbiAgcmV0dXJuIHsgY29ubmVjdGlvblN0YXR1cywgc3Vic2NyaWJlLCB1bnN1YnNjcmliZSwgc2VuZCB9O1xufTtcblxuLy8gS2VlcCB0aGUgb3JpZ2luYWwgaG9vayBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuZXhwb3J0IGNvbnN0IHVzZVdlYlNvY2tldCA9ICh1cmw6IHN0cmluZykgPT4ge1xuICBjb25zdCBbaXNDb25uZWN0ZWQsIHNldElzQ29ubmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2xhc3RNZXNzYWdlLCBzZXRMYXN0TWVzc2FnZV0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3Qgd3MgPSB1c2VSZWY8V2ViU29ja2V0IHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB3cy5jdXJyZW50ID0gbmV3IFdlYlNvY2tldCh1cmwpO1xuXG4gICAgd3MuY3VycmVudC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICBzZXRJc0Nvbm5lY3RlZCh0cnVlKTtcbiAgICAgIGNvbnNvbGUubG9nKCdXZWJTb2NrZXQgY29ubmVjdGVkJyk7XG4gICAgfTtcblxuICAgIHdzLmN1cnJlbnQub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBzZXRMYXN0TWVzc2FnZShldmVudC5kYXRhKTtcbiAgICB9O1xuXG4gICAgd3MuY3VycmVudC5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpO1xuICAgICAgY29uc29sZS5sb2coJ1dlYlNvY2tldCBkaXNjb25uZWN0ZWQnKTtcbiAgICB9O1xuXG4gICAgd3MuY3VycmVudC5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKCdXZWJTb2NrZXQgZXJyb3I6JywgZXJyb3IpO1xuICAgIH07XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd3MuY3VycmVudD8uY2xvc2UoKTtcbiAgICB9O1xuICB9LCBbdXJsXSk7XG5cbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSAobWVzc2FnZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHdzLmN1cnJlbnQ/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICB3cy5jdXJyZW50LnNlbmQobWVzc2FnZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IGlzQ29ubmVjdGVkLCBsYXN0TWVzc2FnZSwgc2VuZE1lc3NhZ2UgfTtcbn07Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VFbmhhbmNlZFdlYlNvY2tldCIsInByb2plY3RJZCIsImNvbm5lY3Rpb25TdGF0dXMiLCJzZXRDb25uZWN0aW9uU3RhdHVzIiwid3MiLCJzdWJzY3JpcHRpb25zIiwiTWFwIiwibWVzc2FnZVF1ZXVlIiwicmVjb25uZWN0QXR0ZW1wdHMiLCJtYXhSZWNvbm5lY3RBdHRlbXB0cyIsImNvbm5lY3QiLCJjdXJyZW50IiwiV2ViU29ja2V0Iiwib25vcGVuIiwiY29uc29sZSIsImxvZyIsImZvckVhY2giLCJjaGFubmVsIiwiZGF0YSIsInNlbmQiLCJvbm1lc3NhZ2UiLCJldmVudCIsIm1lc3NhZ2UiLCJKU09OIiwicGFyc2UiLCJjYWxsYmFjayIsImdldCIsInR5cGUiLCJlcnJvciIsIm9uY2xvc2UiLCJkZWxheSIsIk1hdGgiLCJtaW4iLCJwb3ciLCJzZXRUaW1lb3V0Iiwib25lcnJvciIsInN1YnNjcmliZSIsInNldCIsInVuc3Vic2NyaWJlIiwiZGVsZXRlIiwicmVhZHlTdGF0ZSIsIk9QRU4iLCJzdHJpbmdpZnkiLCJwdXNoIiwiY2xvc2UiLCJ1c2VXZWJTb2NrZXQiLCJ1cmwiLCJpc0Nvbm5lY3RlZCIsInNldElzQ29ubmVjdGVkIiwibGFzdE1lc3NhZ2UiLCJzZXRMYXN0TWVzc2FnZSIsInNlbmRNZXNzYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useWebSocket.ts\n"));

/***/ })

});